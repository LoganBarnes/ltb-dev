
.. _program_listing_file_ltb-util_include_ltb_util_atomic_data.hpp:

Program Listing for File atomic_data.hpp
========================================

|exhale_lsh| :ref:`Return to documentation for file <file_ltb-util_include_ltb_util_atomic_data.hpp>` (``ltb-util/include/ltb/util/atomic_data.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   // ///////////////////////////////////////////////////////////////////////////////////////
   // Copyright (c) 2021 Logan Barnes - All Rights Reserved
   // ///////////////////////////////////////////////////////////////////////////////////////
   #pragma once
   
   // standard
   #include <condition_variable>
   #include <iostream>
   #include <mutex>
   #include <thread>
   
   namespace ltb::util {
   
   struct ScopedLock {
       std::shared_ptr<std::mutex>                  mutex = nullptr;
       std::shared_ptr<std::lock_guard<std::mutex>> lock  = nullptr;
   };
   
   template <typename T>
   class AtomicData {
   public:
       explicit AtomicData(T&& data = T{});
   
       template <typename... Args>
       explicit AtomicData(Args&&... args);
   
       template <typename Func>
       auto use_safely(Func func);
   
       template <typename Func>
       auto use_safely(Func func) const;
   
       auto load() const -> T;
   
       auto store(T t) -> void;
   
       template <typename Pred, typename Func>
       auto wait_to_use_safely(Pred predicate, Func func) -> void;
   
       template <typename Pred, typename Func>
       auto wait_to_use_safely(Pred predicate, Func func) const -> void;
   
       template <typename Rep, typename Period, typename Pred, typename Func>
       auto wait_to_use_safely(std::chrono::duration<Rep, Period> const& duration, Pred predicate, Func func) -> bool;
   
       template <typename Rep, typename Period, typename Pred, typename Func>
       auto wait_to_use_safely(std::chrono::duration<Rep, Period> const& duration, Pred predicate, Func func) const
           -> bool;
   
       auto notify_one() -> void;
   
       auto notify_all() -> void;
   
       [[nodiscard]] auto scoped_lock() const -> ScopedLock;
   
   private:
       std::shared_ptr<std::mutex>              lock_;
       std::shared_ptr<std::condition_variable> condition_;
       T                                        data_;
   };
   
   template <typename T>
   AtomicData<T>::AtomicData(T&& data)
       : lock_(std::make_shared<std::mutex>()),
         condition_(std::make_shared<std::condition_variable>()),
         data_(std::forward<T>(data)) {}
   
   template <typename T>
   template <typename... Args>
   AtomicData<T>::AtomicData(Args&&... args)
       : lock_(std::make_shared<std::mutex>()),
         condition_(std::make_shared<std::condition_variable>()),
         data_(std::forward<Args>(args)...) {}
   
   template <typename T>
   template <typename Func>
   auto AtomicData<T>::use_safely(Func func) {
       std::lock_guard<std::mutex> scoped_lock(*lock_);
       return func(data_);
   }
   
   template <typename T>
   template <typename Func>
   auto AtomicData<T>::use_safely(Func func) const {
       std::lock_guard<std::mutex> scoped_lock(*lock_);
       return func(data_);
   }
   
   template <typename T>
   auto AtomicData<T>::load() const -> T {
       return use_safely([](auto data) { return data; });
   }
   
   template <typename T>
   auto AtomicData<T>::store(T data) -> void {
       use_safely([data](auto& stored_data) { stored_data = data; });
   }
   
   template <typename T>
   template <typename Pred, typename Func>
   auto AtomicData<T>::wait_to_use_safely(Pred predicate, Func func) -> void {
       std::unique_lock<std::mutex> unlockable_lock(*lock_);
       condition_->wait(unlockable_lock, [&] { return predicate(data_); });
       func(data_);
   }
   
   template <typename T>
   template <typename Pred, typename Func>
   auto AtomicData<T>::wait_to_use_safely(Pred predicate, Func func) const -> void {
       std::unique_lock<std::mutex> unlockable_lock(*lock_);
       condition_->wait(unlockable_lock, [&] { return predicate(data_); });
       func(data_);
   }
   
   template <typename T>
   template <typename Rep, typename Period, typename Pred, typename Func>
   auto AtomicData<T>::wait_to_use_safely(std::chrono::duration<Rep, Period> const& duration, Pred predicate, Func func)
       -> bool {
       std::unique_lock<std::mutex> unlockable_lock(*lock_);
       if (condition_->wait_for(unlockable_lock, duration, [&] { return predicate(data_); })) {
           func(data_);
           return true;
       }
       return false;
   }
   
   template <typename T>
   template <typename Rep, typename Period, typename Pred, typename Func>
   auto AtomicData<T>::wait_to_use_safely(std::chrono::duration<Rep, Period> const& duration,
                                          Pred                                      predicate,
                                          Func                                      func) const -> bool {
       std::unique_lock<std::mutex> unlockable_lock(*lock_);
       if (condition_->wait_for(unlockable_lock, duration, [&] { return predicate(data_); })) {
           func(data_);
           return true;
       }
       return false;
   }
   
   template <typename T>
   auto AtomicData<T>::notify_one() -> void {
       condition_->notify_one();
   }
   
   template <typename T>
   auto AtomicData<T>::notify_all() -> void {
       condition_->notify_all();
   }
   
   template <typename T>
   auto AtomicData<T>::scoped_lock() const -> ScopedLock {
       ScopedLock lock{lock_};
       lock.lock = std::make_shared<std::lock_guard<std::mutex>>(*lock.mutex);
       return lock;
   }
   
   } // namespace ltb::util
